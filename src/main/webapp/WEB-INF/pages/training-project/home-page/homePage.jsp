<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/training-project/home-page" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page home-page-page">
    <h1>5.4 Домашняя страница</h1>

    <br/>

    <p class="introduction">
        Настала пора создать нашу первую страницу, используя готовый макет.
        Мы начнём с домашней страницы, так как она является главной в приложении и
        осуществляет навигацию пользователя по его ключевым разделам.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.4.1 Стиль кода и методология БЭМ</h2>
    <br/>
    
    <p>
        Перед тем как мы приступим к реализации нашей первой страницы приложения,
        важно  установить определенные соглашения по наименованию CSS-классов, компонентов,
        элементов со всей командой. Все члены команды должны придерживаться единого
        установленного стиля кода. Если этим пренебречь, в коде проекта очень скоро начнётся
        настоящая вакханалия! На чтение такого кода будет уходить очень много времени и каждый
        компонент будет резать глаза. Будет создаваться впечатление, что код писали индусы
        из 10 разных сёл. Поверьте, я через это проходил.
    </p>
    
    <c:url var="jsCodeStyleUrl" value="https://github.com/leonidlebedev/javascript-airbnb"/>
    <c:url var="reactCodeStyleUrl" value="https://github.com/leonidlebedev/javascript-airbnb/tree/master/react"/>
    
    <p>
        Не менее важно установить единый стиль написания компонентов. Они не должны быть
        разношёрстными, все методы должны идти в определённом порядке. Есть очень хорошие
        ресурсы по <b><a href="${jsCodeStyleUrl}">стилю написания кода JavaScript</a></b>,
        а  также <b><a href="${reactCodeStyleUrl}">стилю кода React/JSX</a></b>. Я настоятельно
        рекомендую вам усвоить информацию из этих источников! Поверьте - это очень важно.
        Ваш код будет красив, ваши компоненты будут простые, а читать исходники будет интереснее,
        чем смотреть “игры престолов”.
    </p>
    
    <p>
        Со стилем кода мы разобрались, теперь стоит рассказать ещё об одной вещи. Когда
        мы пишем разметку наших компонентов, то часто используем CSS-классы. Стиль их имён
        тоже имеет большое значение. Во-первых - единый стиль имён легко читать. А во
        вторых, правильно подобранный стиль имён позволит избежать уменьшения производительности UI.
    </p>
    
    <c:url var="bemUrl" value="https://ru.bem.info/methodology/"/>
    
    <p>
        Если кто-то ещё не знаком, то самое время познакомиться с замечательной
        методологией, под названием <b><a href="${bemUrl}">БЭМ</a></b>. Я опять же настаиваю на том, чтобы вы
        полностью изучили все разделы сайта. Это ощутимо поднимет ваш уровень
        знаний и откроет глаза на многие, казалось бы, незаметные вещи. Материал
        читается быстро и легко, а пользу трудно переоценить.
    </p>
    
    <p>
        Мы в своём коде будем использовать вот это соглашение. То есть схема
        именования наших CSS-классов будет такой:
    </p>
    
    <ce:code-example-1/>
    
    <ul>
        <li>
            <p>
                Имена записываются латиницей.
            </p>
        </li>
        <li>
            <p>
                Имена блоков и элементов пишутся с заглавной буквы. Имена модификаторов — со строчной.
            </p>
        </li>
        <li>
            <p>
                Каждое слово внутри имени пишется с заглавной буквы.
            </p>
        </li>
        <li>
            <p>
                Имя элемента отделяется от имени блока одним дефисом (-).
            </p>
        </li>
        <li>
            <p>
                Разделители имени и значения модификаторов совпадают с классической схемой.
            </p>
        </li>
    </ul>
    
    <ad:ad-content-banner-1/>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.4.2 Используем SASS</h2>
    <br/>
    
    <c:url var="sassUrl" value="https://sass-scss.ru/"/>
    
    <p>
        Если вы ещё не знакомы с этим мощным расширением CSS, самое время его
        изучить. Есть отличная <b><a href="${sassUrl}">русскоязычная документация</a></b>. Очень скоро мы
        создадим некоторые полезные CSS классы, используя синтаксические
        конструкции SASS. Рассказывать о нём здесь не имеет смысла, куда
        красноречивее расскажут сами создатели. А мы, двигаемся дальше...
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.4.3 Используем flexbox</h2>
    <br/>
    
    <p>
        Эта полезная возможность CSS обеспечит нам большую скорость
        разработки стилей. Многие, не исключая меня, любят её за простоту
        и потрясающие возможности по компоновке элементов разметки.
    </p>
    
    <c:url var="postProcessingCssUrl" value="https://facebook.github.io/create-react-app/docs/post-processing-css"/>
    <c:url var="autoprefixerUrl" value="https://github.com/postcss/autoprefixer"/>
    <c:url var="flexboxUrl" value="https://html5book.ru/css3-flexbox/"/>
    
    <p>
        Вы, возможно, уже использовали flex-ы и можете заявить, а как же кроссбраузерность?
        Не “поедет” ли разметка в некоторых браузерах? <b><a href="${postProcessingCssUrl}">В этом разделе</a></b> документации проекта
        create-react-app написано, что проект умеет делать пост обработку CSS и
        самостоятельно добавлять вендорские префиксы с помощью <b><a href="${autoprefixerUrl}">Autoprefixer</a></b>. Нужно лишь
        указать целевые браузеры в <code>browserslist</code> в файле <code>package.json</code>. Отличный
        русскоязычный источник по flexbox вы можете <b><a href="${flexboxUrl}">найти здесь</a></b>.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.4.4 Bootstrap и другие известные UI библиотеки</h2>
    <br/>
    
    <c:url var="reactUiUrl" value="https://www.codeinwp.com/blog/react-ui-component-libraries-frameworks/"/>
    
    <p>
        Все веб-разработчики слышали или использовали такую популярную библиотеку как
        Bootstrap. Однако сообщество React создало для себя и другие богатые библиотеки:
        React Bootstrap, Material UI, React Virtualized, Blueprint, Semantic UI React,
        React Toolbox и многие другие. Расширенный список вы можете <b><a href="${reactUiUrl}">посмотреть здесь</a></b>.
        Эти библиотеки предлагают вам изобилие разных компонентов на любой вкус.
    </p>
    
    <p>
        Когда вы начинаете свой проект, лучше выбрать для себя <b>одну</b> такую библиотеку, как
        основу. Если подключить несколько - есть вероятность конфликтов JS кода и стилей,
        а также появления странных багов. По возможности библиотека должна реализовывать
        все типовые компоненты: модальные окна, кнопки, таблицы, табовые панели и пр. -
        чтобы вы не писали их сами. Затем, недостающие компоненты можно искать и подключать
        по отдельности, либо писать самостоятельно.
    </p>
    
    <p>
        В нашем приложении мы будем использовать Bootstrap и React-Bootstrap. Из первой
        мы где-то используем, а где-то переопределим кое-какие стили. А из второй будем
        использовать готовые React компоненты.
    </p>
    
    <p>Давайте добавим модуль bootstrap в наше приложение:</p>
    
    <br/>
    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/add-bootstrap-package.png"/>" class="text-center">
    </p>
    <br/>
    
    <c:url var="addingBootstrapUrl" value="https://facebook.github.io/create-react-app/docs/adding-bootstrap"/>
    
    <p>
        О том как подключить стили Bootstrap отлично <b><a href="${addingBootstrapUrl}">написано здесь</a></b>. Мы последуем этим
        инструкциям и сперва создадим файл <b>main.scss</b>  - это будет наш главный файл, где
        будем подключать различные стили, как библиотечные, так и свои собственные. Затем
        подключим его в файле <b>index.scss</b>.
    </p>
    
    <p>
        Внимание! Как вы заметили, файлы имеют расширение <b>.scss</b> - это расширение файла <b>SASS</b>.
        В таком файле можно использовать все мощные возможности этого фреймворка. Главное не
        переусердствуйте :)
    </p>
    
    <ad:ad-content-banner-2/>
    
    <p>
        Мы могли бы подключать стили и прямо в файле <b>index.scss</b>, однако вариант с файлом <b>main.scss</b>
        более гибкий. Помимо него мы сможем в <b>index.scss</b> подключить и любой другой необходимый файл.
        Просто дополнительный промежуточный уровень для гибкости.
    </p>
    
    <p>Далее согласно документации в файле main.scss подключим стили bootstrap:</p>
    
    <ce:code-example-2/>
    
    <br/>
    
    <iframe
        height="400px"
        width="100%"
        src="https://repl.it/@stsiushkevich/custom-app-20?lite=true"
        scrolling="no"
        frameborder="no"
        allowtransparency="true"
        allowfullscreen="true"
        sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>
    
    <br/>
    <br/>
    
    <app:alert title="Внимание!" type="warning">
        Важно! Если вы подключаете стили из <code>node_modules</code>, то в
        импорте должны использовать префикс <code>~</code>.
    </app:alert>
    
    <p>
        Их можно переопределить. Для этого достаточно написать свои собственные стили
        сразу после этой строки подключения:
    </p>
    
    <ce:code-example-3/>
    
    <p>
        Однако такой способ пригоден только в тех случаях, когда приложение маленькое. Для
        больших проектов с множеством переопределений при таком способе очень быстро начинает
        страдать скорость поиска нужного стиля и читабельность, особенно у тех, кто знаком с
        вашим проектом совсем недавно. Чтобы этого избежать, переопределяемые стили лучше
        группировать по отдельным файлам, которые затем следует подключить в <b>main.scss</b> после
        строки подключения стилей  bootstrap (и других сторонних библиотек).
    </p>
    
    <p>
        Для переопределения стилей в нашем приложении, давайте создадим папку <b>custom</b>, где
        разместим все наши файлы переопределения стилей bootstrap. В этой папке создадим два
        файла переопределения <b>common.scss</b> и <b>buttons.scss</b>. В первом будем хранить универсальные
        стили, а во втором будем переопределять стили кнопок bootstrap, согласно нашей цветовой гамме.
    </p>
    
    <br/>
    
    <iframe
        height="400px"
        width="100%"
        src="https://repl.it/@stsiushkevich/custom-app-v30?lite=true"
        scrolling="no"
        frameborder="no"
        allowtransparency="true"
        allowfullscreen="true"
        sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>
    
    <br/>
    <br/>
    
    <p>
        В файле <b>common.scss</b> мы определили циклы для генерации полезных CSS классов, используя
        синтаксис SASS. Представляете, сколько заняло бы места и времени написать их, используя
        простой CSS? При этом читабельность просто отличная!
    </p>
    
    <p>
        В файле <b>buttons.scss</b> мы пока определили один класс <code>.btn-primary</code>. Он переопределяет
        оригинальный CSS-класс bootstrap. Мы добавим ещё переопределений по мере продвижения.
    </p>
    
    <p>
        Теперь, когда со стилями мы разобрались, пора приступить к созданию
        компонента домашней страницы.
    </p>
    
    <p>
        Ещё хочу обратить ваше внимание на файл <b>index.js</b>. В нём мы сначала подключаем
        стили, а потом компоненты. Это важно, так как если сделать наоборот, общие стили
        будут переопределять стили компонентов.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.4.5 Компонент домашней страницы</h2>
    <br/>
    
    <p>Итак, давайте создадим компонент домашней страницы:</p>
    
    <br/>
    
    <iframe
        height="400px"
        width="100%"
        src="https://repl.it/@stsiushkevich/custom-app-v31?lite=true"
        scrolling="no"
        frameborder="no"
        allowtransparency="true"
        allowfullscreen="true"
        sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>
    
    <br/>
    <br/>
    
    <p>Теперь проанализируем код приложения.</p>
    
    <ad:ad-content-banner-3/>
    
    <p>
        Мы создали компонент <code>&lt;Home/&gt;</code>. В начале файла идут все необходимые импорты.
        Обратите внимание, я расположил их в определённом порядке, разделяя пустыми
        строками. Это важно, так как сильно улучшает читабельность. В общем случае порядок
        импортов может быть такой:
    </p>
    
    <ol>
        <li>
            <p>
                Импорт самой библиотеки React: <code>import React, { Component } from 'react'</code>
            </p>
        </li>
        <li>
            <p>
                Пустая строка
            </p>
        </li>
        <li>
            <p>
                Импорт всех сторонних библиотек. Эти библиотеки также можно объединять в группы,
                отделяя последние пустой строкой:
                
                <br/>
                
                <ce:code-example-4/>
            </p>
        </li>
        <li>
            <p>
                Пустая строка
            </p>
        </li>
        <li>
            <p>
                Импорт всех необходимых пользовательских компонентов
            </p>
        </li>
        <li>
            <p>
                Пустая строка
            </p>
        </li>
        <li>
            <p>
                Импорт стилей компонента
            </p>
        </li>
        <li>
            <p>
                Пустая строка
            </p>
        </li>
        <li>
            <p>
                Импорт всех необходимых redux-действий
            </p>
        </li>
        <li>
            <p>
                Пустая строка
            </p>
        </li>
        <li>
            <p>
                Импорт всех необходимых пользовательских утилит
            </p>
        </li>
    </ol>
    
    <p>
        Представленный порядок импортов, может быть изменен или дополнен командой. Очень
        важно, чтобы все члены команды его придерживались, тогда это принесёт ощутимую пользу
        в плане читабельности. Вот более полный пример того, как можно расположить импорты:
    </p>
    
    <ce:code-example-5/>
    
    <p>
        Вы можете заметить ещё одну интересную деталь: импорты в пределах группы расположены
        в порядке длинны строки. Более короткая строка импорта идет перед более длинной. Так
        делать не обязательно, можно задавать и какой-то другой порядок (или вообще не задавать).
        Но по моему личному мнению, импорты в таком порядке смотрятся очень аккуратно, а значит и
        читабельность лучше.
    </p>
    
    <p>
        С импортами мы разобрались. Далее мы объявляем все необходимые константы. В нашем случае это
        <code>SECTIONS</code>. В этой константе хранятся атрибуты для каждого раздела: название, ссылка и иконка.
        Реализация не обязана быть именно такой. Необязательно было сохранять в локальной константе
        иконки, хоть это и распространённая практика. Для раздела можно было бы создать компонент-функцию,
        например:
    </p>
    
    <ce:code-example-6/>
    
    <c:url var="underscorejsUrl" value="http://underscorejs.ru/"/>
    
    <p>
        Далее в методе <code>render()</code> мы отрисовываем все разделы, используя
        метод <code>map</code> библиотеки <b><a href="${underscorejsUrl}">underscore</a></b>.
        Эта библиотека является очень мощным инструментом при работе с коллекциями, массивами и объектами.
        Она имеет богатый API и позволяет сильно сократить код, предоставляя готовые методы для многих
        типовых задач: поиск, сортировка, клонирование, определение типа, проверка на пусто и многое
        многое другое. Очень рекомендую использовать её в ваших проектах.
    </p>
    
    <ad:ad-content-banner-4/>
    
    <c:url var="addingImagesFontsAndFilesUrl" value="https://facebook.github.io/create-react-app/docs/adding-images-fonts-and-files"/>
    
    <p>
        Отдельно стоит сказать об изображениях. В проекте мы используем файлы <code>.svg</code>. Они полезны
        тем, что позволяют изменять свой цвет и отлично масштабируются. В <b><a href="${addingImagesFontsAndFilesUrl}">документации</a></b> подробно
        описано как их можно подключать. А подключать их мы можем подключить двумя способами:
        как обычное изображение (например как файл <code>.png</code>) и как <code>ReactComponent</code>. Во втором случае
        изображение не будет загружаться как отдельный файл. <code>ReactComponent</code> - это специальное
        имя, которое говорит Create React App о том, что вы определяете компонент React, который
        будет отрисовывать SVG.
    </p>
    
    <p>
        С учётом вышесказанного, подключение и использование <code>.svg</code> изображения в нашем
        проекте выглядит следующим образом:
    </p>
    
    <ce:code-example-7/>
    
    <p>
        Как видно, изображение представлено компонентом, которому мы можем назначить наш собственный
        CSS-класс. В этом классе мы задаём все необходимые стили изображения:
    </p>
    
    <ce:code-example-8/>
    
    <p>Цвет изображения можно изменить с помощью свойства <code>fill</code>.</p>
    
    <p>
        Напоследок поговорим о компоненте <code>&lt;Header&gt;</code>. Он является общим для большинства
        страниц приложения, поэтому и реализован как отдельный переиспользуемый компонент.
        Он отображает название страницы, иконку, имя текущего пользователя и кнопку выхода
        из приложения. Стиль кнопки мы переопределили аж двумя классами: <code>.btn-primary</code> в
        <b>buttons.scss</b> и <code>.Header-ExitBtn</code> в <b>Header.scss</b>. В первом классе мы изменили лишь фон,
        а во втором переопределили границу. Дело в том, что такая граница кнопки характерна
        только для этой страницы. На другой странице такая граница может быть неприемлема.
    </p>
    
    <p>
        Компонент <code>&lt;Header&gt;</code> использует библиотеку <code>classnames</code>. Это очень полезная библиотека,
        когда дело касается работы с CSS-классами. Она позволяет избежать конструкции типа:
    </p>
    
    <ce:code-example-9/>
    
    <p>Вместо этого можно записать:</p>
    
    <ce:code-example-10/>
    
    <c:url var="classnamesUrl" value="https://www.npmjs.com/package/classnames"/>
    <c:url var="mixUrl" value="https://ru.bem.info/methodology/key-concepts/#%D0%BC%D0%B8%D0%BA%D1%81"/>
    
    <p>Более подробно можно почитать <b><a href="${classnamesUrl}">здесь</a></b>.</p>
    
    <p>
        Обратите внимание на CSS-классы: <code>flex-1 d-flex flex-row justify-content-start
        align-items-center</code>. Здесь мы не придумывали какие-то свои, а использовали уже
        готовые. Класс <code>flex-1</code> взяли из нашего <b>common.scss</b>, а остальные нам предоставил
        bootstrap. Такой способ использования разных сущностей на одном DOM узле в БЭМ
        называется <b><a href="${mixUrl}">миксом</a></b>. В случаях, когда свой собственный CSS класс будет избыточен
        мы вполне можем использовать этот подход.
    </p>
    
    <p>
        Также компонент <code>&lt;Header&gt;</code> использует метод <code>renderIcon</code>. Он нужен для того,
        чтобы отрисовывать иконку текущей страницы.
    </p>
    
    <p>
        Ну что ж, компонент домашней страницы готов, теперь можно перейти к реализации списка приёмов,
        использовав библиотеку для создания таблиц.
    </p>
</lt:layout>

<c:url var="prevPageUrl" value="/training-project/page-mockups"/>
<c:url var="nextPageUrl" value="/training-project/appointments"/>

<app:page-navigate
        prevPageUrl="${prevPageUrl}"
        pageStartAncor="pageStart"
        nextPageUrl="${nextPageUrl}"
/>