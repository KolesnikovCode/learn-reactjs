<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/training-project/practice" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<c:url var="Url" value=""/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page practice-page">
    <h1>5.10 Практические задания</h1>

    <br/>

    <p class="introduction">
        Чтобы как следует усвоить полученную информацию нужно хорошо попрактиковаться.
        Это особенно актуально для  программирования. Чтобы сделать этот процесс
        максимально полезным, я подготовил для вас набор типовых задач, которые очень
        часто возникают в приложениях.
    </p>

    <p>
        Помимо задач есть и подсказки. Вы можете обратиться к ним сразу, если совсем
        непонятно, что нужно сделать. Либо можно сделать всё самому, а затем посмотреть
        подсказку, чтобы сравнить варианты исполнения. Возможно, вы предложите даже
        более изящное решение! Если вдруг это произойдёт, не жадничайте и
        делитесь вашими идеями в комментариях)
    </p>
    
    <c:url var="webStromUrl" value="https://www.jetbrains.com/webstorm/promo/?gclid=Cj0KCQiA2ITuBRDkARIsAMK9Q7Pam77y7HfwxdjvTIrdbziwLF2GMPv1mEOLJjAqxuC_RFCibL8y-0kaAjohEALw_wcB&gclsrc=aw.ds"/>
    <c:url var="createReactAppUrl" value="https://github.com/facebook/create-react-app"/>
    
    <p>
        Для работы я рекомендую среду <b><a href="${webStromUrl}">WebStorm</a></b>, создав проект
        на основе приложения <b><a href="${createReactAppUrl}">create-react-app</a></b>.
    </p>
    
    <p>
        Задачи отсортированы по возрастанию сложности. Решив их все, я уверен,
        что вы окончательно устраните все пробелы и будете готовы написать с нуля
        своё собственное приложение. Итак, поехали!
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №1</h2>
    <br/>
    
    <p>
        <b>
            На странице списка приёмов добавьте в фильтр следующие поля:
            "Статус", "Принимающий" и "Жалобы".
        </b>
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №2</h2>
    <br/>
    
    <p>
        <b>
            На странице списка приёмов добавьте в фильтр кнопку "Сброс",
            наделив ее какой-нибудь svg-иконкой по аналогии с кнопкой "Поиск". По
            нажатии на "Сброс" поля фильтра должны быть очищены, а список перезагружен
            с пустыми параметрами фильтрации.
        </b>
    </p>
    
    <br/>
    
    <p>
        <b><i>Подсказка:</i></b> для того, чтобы сбросить фильтр, нам понадобится
        уже реализованное действие <code>cleanFilter()</code>.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №3</h2>
    <br/>
    
    <p>
        <b>
            На странице списка приёмов сделайте скрывающийся фильтр,
            используя компонент <code>&lt;Collapse&gt;</code> библиотеки <code>reactstrap</code>.
        </b>
    </p>
    
    <p>
        Для распахивания/скрытия фильтра использовать svg-иконку в правом верхнем углу:
    </p>
    
    <br/>
    
    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/appointments-collapsible-filter.png"/>" class="text-center">
    </p>
    
    <br/>
    <br/>
    
    <p>
        По умолчанию фильтр должен быть скрыт. Фильтр вынести в отдельный
        компонент-контейнер <code>&lt;AppointmentFilter&gt;</code>, поместив его в папку <code>/Appointments</code>.
        Компонент фильтра должен иметь доступ к определённой части состояния и действиям redux.
    </p>
    
    <br/>
    
    <p>
        <b><i>Подсказка:</i></b> когда мы переносим фильтр в отдельный компонент-контейнер,
        последний будет иметь доступ к состоянию и действиям списка. Сам компонент будет
        выглядеть примерно так:
    </p>
    
    <ce:code-example-1/>
    
    <p>
        Компонент <code>&lt;Appointments&gt;</code> нужно очистить от лишних методов, тем самым
        упростив его код.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №4</h2>
    <br/>
    
    <p>
        <b>
            На странице списка приёмов добавьте сортировку в следующие
            столбцы таблицы: "Дата", "Клиент", "Статус" и "Принимающий". Сортировка
            должна происходить на стороне сервера(фейкового), а на клиент приходят
            готовые отсортированные данные.
        </b>
    </p>
    
    <br/>
    
    <p>
        <b><i>Подсказка.</i></b> Чтобы организовать сортировку понадобится сделать
        несколько вещей:
    </p>
    
    <ol>
        <li>
            <c:url var="sortingUrl" value="https://react-bootstrap-table.github.io/react-bootstrap-table2/storybook/index.html?selectedKind=Sort%20Table&selectedStory=Sort%20Events&full=0&addons=1&stories=1&panelRight=0&addonPanel=storybook%2Factions%2Factions-panel"/>
            <p>
                Включить сортировку на необходимых столбцах используя <b><a href="${sortingUrl}">свойства
                sort и onSort плагина таблицы</a></b>.
            </p>
        </li>
        <li>
            <p>
                По событию <code>onSort</code> список следует перезагрузить, передав на
                сервер поле сортировки.
            </p>
        </li>
        <li>
            <p>
                Redux состояние списка будет содержать новое свойство <code>sorting</code>:
                
                <ce:code-example-2/>
            </p>
        </li>
        <li>
            <p>
                Добавится новое действие <code>sort()</code>:
                
                <ce:code-example-3/>
            </p>
        </li>
        <li>
            <p>
                Метод <code>load()</code> компонента <code>&lt;Appointments&gt;</code> будет передавать дополнительный
                параметр <code>sort</code>, равный значению <code>sort='fieldName,order'</code>
                (например <code>sort='firstName,desc'</code>). Сервер парсит это строковое значение
                и возвращает отсортированный список.
            </p>
        </li>
    </ol>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №5</h2>
    <br/>
    
    <p>
        <b>
            На странице списка приёмов увеличить количество
            тестовых данных и реализовать пагинацию.
        </b>
    </p>
    
    <br/>
    
    <p>
        <b><i>Подсказка.</i></b> Чтобы увеличить количество тестовых данных следует
        отрефакторить код файла <code>MockData.js</code>. Сейчас там просто статический
        список <code>appointments</code>. Чтобы придать этому списку произвольный размер,
        нужно сделать его динамическим. Это значит, что нужно создать метод
        <code>createAppointments(N)</code>, который будет создавать <code>N</code> элементов списка при
        старте приложения. Чтобы данные списка были разнообразными, нужно
        построить несколько дополнительных статических списков: список
        имен <code>firstNames</code>, список фамилий <code>lastNames</code>, список диагнозов и
        так далее. Затем при конструировании элемента динамического списка
        appointments, мы для каждого элемента случайным образом выбираем
        имя, фамилию, диагноз и пр. из статических списков.
    </p>
    
    <p>
        Чтобы реализовать пагинацию, в Redux состояние списка приёмов
        следует добавить новое свойство <code>pagination</code>:
    </p>
    
    <ce:code-example-4/>
    
    <p>
        Под страницей понимается количество/часть элементов списка, показываемых
        пользователю в данный момент. Соответственно нам нужны такие параметры
        как номер/индекс и размер части, а также общее количество элементов
        (для корректной работа пагинатора таблицы).
    </p>
    
    <c:url var="paginationUrl" value="https://react-bootstrap-table.github.io/react-bootstrap-table2/storybook/index.html?selectedKind=Remote&selectedStory=Remote%20Pagination&full=0&addons=1&stories=1&panelRight=0&addonPanel=storybook%2Factions%2Factions-panel"/>
    
    <p>
        Пример подключения пагинатора в компоненте таблицы можно <b><a href="${paginationUrl}">увидеть здесь</a></b>.
        В компоненте <code>&lt;Table&gt;</code> рекомендую добавить
        метод <code>onRefresh</code>:
    </p>
    
    <ce:code-example-5/>
    
    <p>
        При срабатывании <code>onRefresh</code> компонента <code>&lt;Table&gt;</code>
        компонент <code>&lt;Appointments&gt;</code> будет загружать необходимую часть
        (страницу) данных списка для значения параметра <code>page</code>. Сервер вычисляет нужную
        часть элементов списка(страницу) и возвращает её.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №6</h2>
    <br/>
    
    <p>
        <b>
            Реализуйте демонстрацию ошибки при неудаче получения данных с
            сервера. Продемонстрировать ошибку следует в виде модального диалога с
            кнопкой ОК, по нажатию на которой диалог пропадает.
        </b>
    </p>
    
    <br/>
    
    <p>
        <b><i>Подсказка.</i></b> в библиотеке <b>reactstrap</b> есть модальное окно.
        Вам понадобится сделать свой универсальный базовый компонент-обёртку
        <code>&lt;Dialog&gt;</code> со всеми необходимыми для вас свойствами
        (<code>props</code>). Компонент <code>&lt;Dialog&gt;</code>, помимо прочих, будет
        содержать такие специфические свойства как: <code>icon</code> (иконка диалога: ошибка,
        успех, информация), <code>title</code> (название диалога) и <code>buttons</code> (кнопки диалога).
        Содержимое диалога будет передаваться через свойство <code>children</code>.
        Использование <code>&lt;Dialog&gt;</code> будет выглядеть приблизительно так:
    </p>
    
    <ce:code-example-6/>
    
    <p>
        Для демонстрации ошибки удобно создать ещё один компонент-обёртку
        вокруг <code>&lt;Dialog&gt;</code>. Назовём его <code>&lt;ErrorViewer&gt;</code>.
        Он будет отрисовывать с компонент диалога с предварительно заданными
        свойствами <code>props</code> (title, icon, text и buttons), которые при необходимости можно
        переопределить.
    </p>
    
    <p>Саму ошибку мы получаем из соответствующей части состояния.</p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №7</h2>
    <br/>
    
    <p><b>Реализуйте аутентификацию. Требования:</b></p>
    
    <ul>
        <li>
            <p>
                При вводе URL приложения пользователь должен быть перенаправлен на
                форму аутентификации.
            </p>
        </li>
        <li>
            <p>
                При успешной аутентификации на форме пользователь должен быть перенаправлен
                на домашнюю страницу, а в заголовке должны отображаться его имя и фамилия.
            </p>
        </li>
    </ul>
    
    <br/>
    
    <p>
        <b><i>Подсказка.</i></b> Работа с формой аналогична работе с фильтром, который
        мы реализовали для списка приёмов. К тому же имеется готовый макет. Важным моментом
        является добавление нескольких тестовых пользователей в фейковую базу <code>MockData.js</code>.
        Создайте в этом файле метод <code>login()</code>, который будет сверять введённые данные с
        этими пользователями. Если есть полное совпадение, аутентификация признаётся
        успешной, а метод возвращает данные найденного пользователя для его последующего
        сохранения в состояние приложения. Эти данные будут доступны на протяжении всего
        сеанса. Простейший вариант реализации метода <code>login()</code>:
    </p>
    
    <ce:code-example-7/>
    
    <p>
        Что касается состояния, то для работы с аутентификацией удобно создать
        поддиректорию <code>/redux/auth</code>, а для формы аутентификации - поддиректорию <code>/redux/login</code>:
    </p>
    
    <br/>
    
    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/redux-login-action.png"/>" class="text-center">
    </p>
    
    <br/>
    <br/>
    
    <p>
        Для выполнения AJAX запросов, связанных аутентификацией (логин, логаут)
        создайте сервис <code>AuthService</code>.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №8</h2>
    <br/>
    
    <p>
        <b>
            Подключите валидацию на форму аутентификации. Валидация должна
            срабатывать, когда пользователь пытается отправить не заполненную форму.
        </b>
    </p>
    
    <br/>
    
    <p>
        <b><i>Подсказка.</i></b> Для валидации неплохо подойдёт плагин <code>validate.js</code>.
        Он обладает обширными возможностями и простотой использования. Валидацию лучше
        организовать через действие (в файле <code>loginFormActions.js</code>). Также подготовьте
        специальный класс-валидатор формы <code>LoginFormValidatоr</code> с методом <code>validate()</code>, который
        можно вызывать в действии. Код действия и валидатора может выглядеть так:
    </p>
    
    <br/>
    
    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/form-validation.png"/>" class="text-center">
    </p>
    
    <br/>
    <br/>
    
    <br/>
    
    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/form-validator.png"/>" class="text-center">
    </p>
    
    <br/>
    <br/>
    
    <p>
        В состояние, для каждого основного поля формы, следует добавить два валидационных:
    </p>
    
    <br/>
    
    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/form-validation-fields.png"/>" class="text-center">
    </p>
    
    <br/>
    <br/>
    
    <p>
        В редюсере, в случае неудачной валидации, мы проинициализируем эти поля,
        а затем отобразим их значения на форме.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №9</h2>
    <br/>
    
    <p>
        <b>
            Реализовать просмотрщик и редактор деталей приёма в виде
            диалоговых окон, используя макеты. Требования:
        </b>
    </p>
    
    <ul>
        <li>
            <p>
                В просмотрщике должна быть показана более подробная информация
                по приёму, чем в списке (придумайте дополнительные данные).
            </p>
            <ul>
                <li>
                    <p>
                        Информация должна быть представлена в виде трёх столбцов.
                    </p>
                </li>
                <li>
                    <p>
                        Просмотрщик должен иметь название "Просмотр приёма", а также
                        содержать кнопку "Закрыть", по нажатию на которой он закрывается.
                    </p>
                </li>
            </ul>
        </li>
        <li>
            <p>
                В редакторе должна отображаться форма для создания/редактирования приёма,
                на которой должна присутствовать валидация.
            </p>
        </li>
        <li>
            <p>
                Если редактор открыт на редактирование приёма, его название должно
                быть "Редактировать приём", а если на создание - "Создать приём".
            </p>
        </li>
        <li>
            <p>
                Редактор должен иметь кнопки "Закрыть" и "Сохранить".
            </p>
            <ul>
                <li>
                    <p>
                        По нажатию на кнопку "Закрыть", редактор должен закрываться.
                    </p>
                </li>
                <li>
                    <p>
                        По нажатию на кнопку "Сохранить", сначала происходит валидация. 
                        Если валидация прошла успешно - данные отправляются на сервер.
                    </p>
                </li>
                <li>
                    <p>
                        Пока ожидается ответ сервера, на диалоге должен показываться "модальный"
                        лоудер, который затеняет все поля формы, не давая возможности её редактировать.
                    </p>
                </li>
                <li>
                    <p>
                        Если данные сохранены успешно - лоудер пропадает, редактор закрывается,
                        а список обновляется.
                    </p>
                </li>
            </ul>
        </li>
        <li>
            <p>
                Для вызова просмотрщика и редактора в таблицу следует добавить дополнительный безымянный столбец.
            </p>
            <ul>
                <li>
                    <p>
                        Каждая ячейка этого столбца должна содержать две кнопки для просмотра
                        (с иконкой глаза) и редактирования (с иконкой карандаша) конкретного приёма.
                    </p>
                </li>
            </ul>
        </li>
        <li>
            <p>
                Над таблицей следует добавить кнопку "Создать" для вызова редактора в
                режиме создания нового приёма.
            </p>
        </li>
    </ul>
    
    <p>Макеты:</p>
    
    <br/>
    
    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/appointment-viewer.png"/>" class="text-center">
    </p>
    
    <br/>
    <br/>
    
    <br/>
    
    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/appointment-editor.png"/>" class="text-center">
    </p>
    
    <br/>
    <br/>
    
    <p>
        <b><i>Подсказка</i></b>. Cледует создать одноимённую компонент-обёртку вокруг компонента
        модального окна reactstrap. Такая обёртка позволит сократить код при использовании
        и расширить возможности.
    </p>
    
    <p>
        Просмотрщик и редактор можно представить компонентами <code>&lt;AppointmentViewer&gt;</code>
        и <code>&lt;AppointmentEditor&gt;</code>, которые будут являться обёртками модального окна.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>Задача №10</h2>
    <br/>
    
    <p>
        <b>
            Реализовать раздел "События" по аналогии с разделом "Приёмы". Требования:
        </b>
    </p>
    
    <ul>
        <li>
            <p>
                Схлопывающийся фильтр
            </p>
        </li>
        <li>
            <p>
                Список с возможностями сортировки и пагинации
            </p>
        </li>
        <li>
            <p>
                Просмотрщик и редактор событий
            </p>
        </li>
    </ul>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <br/>
    
    <p>
        Вот, пожалуй, и весь перечень практических задач. Я очень надеюсь, что их
        решение принесёт вам существенную пользу, разрешив многие вопросы и улучшив
        ваши практические навыки.
    </p>
    
    <p>
        Что ж, настало время закончить эту большую главу. Не забывайте изучать новые
        концепции и возможности React, согласовано интегрируйте их в проект и не забывайте
        про качество кода. Успехов вам в этом удивительном мире фронтенда!
    </p>
</lt:layout>

<c:url var="prevPageUrl" value="/training-project/summary"/>

<app:page-navigate
        prevPageUrl="${prevPageUrl}"
        pageStartAncor="pageStart"
/>