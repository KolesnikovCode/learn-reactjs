<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/training-project/async-data-loading" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<c:url var="Url" value=""/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page async-data-loading-page">
    <h1>5.7 Асинхронная загрузка данных</h1>

    <br/>

    <p class="introduction">
        Большинство веб-приложений работают с данными, которые, как правило, хранятся
        в базе данных (БД). Что получить эти данные приложения обычно используют AJAX,
        то есть асинхронные запросы к серверу. Сервер, получив такой запрос, обращается
        к БД, а затем возвращает данные обратно приложению. Здесь мы подробнее рассмотрим
        суть асинхронной загрузки данных и её возможную реализацию.
    </p>

    <br/>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.7.1 Мотивация</h2>
    <br/>

    <p>
        Теперь мы подошли к важной части: взаимодействие сервера и клиента. Наш клиент
        написан на React, сервер же может быть написан на чём угодно: <b>Java</b>, <b>C#</b>, <b>PHP</b>,
        <b>Kothlin</b>, <b>JavaScript</b> и т.д. Это здорово, когда над проектом трудятся одновременно
        две команды: <b>frontend</b> и <b>backend</b>. Но очень частой является ситуация, когда <b>backend</b>
        разрабатывается медленнее или его в данный момент вообще нет. Такое происходит
        по ряду причин: мало разработчиков, сложная бизнес-логика, нет средств на
        разработку и пр. Но клиент делать нужно, мало того он должен работать с какими-то
        данными, чтобы можно было демонстрировать результаты труда.
    </p>

    <p>
        Ранее мы уже говорили о фиктивных данных и даже создали их. Далее мы
        усовершенствуем уже имеющийся код. Главная задача данного раздела:
        <b>эмулировать сервер</b>, который будет возвращать данные. Данные же будут
        фейковые, но пользователю будет казаться, что приложение работает с
        настоящим сервером: будет показываться лоудер загрузки, будут приходить
        данные и т.д. То есть будет работать весь функционал, будто всё
        по-настоящему. Также мы добавим возможность переключения приложения с
        фейковых данных на реальные только с помощью файла <code>config.js</code>.
    </p>

    <p>
        Что ж, не будем терять времени и приступим к созданию фиктивного сервера!
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.7.2 Взаимодействие клиент-сервер</h2>
    <br/>

    <p>
        Давайте повторим базовые стадии взаимодействия клиент-сервер. На основании
        этого мы будем проектировать наш фейковый сервер.
    </p>

    <c:url var="clientServerUrl" value="https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_%E2%80%94_%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80"/>
    <c:url var="httpUrl" value="https://ru.wikipedia.org/wiki/HTTP"/>

    <p>
        Итак, у нас есть клиент. Обычно это программа, которая запрашивает данные
        по определённом протоколу у сервера. Как правило, мы используем протокол <b>HTTPS</b> - это <b>HTTP</b> с
        шифрованием. Сначала клиент создаёт запрос определённого типа: <b>GET</b>, <b>POST</b>, <b>PUT</b>, <b>DELETE</b> и т.д.
        Также он может добавить в запрос какие-то данные, например данные формы,
        если запрос типа <b>POST</b> или <b>PUT</b>. Кроме этого клиент может указать заголовки и
        параметры запроса. Когда запрос создан, клиент посылает его серверу.
        Про <b><a href="${clientServerUrl}">архитектуру клиент-сервер</a></b> и
        <b><a href="${httpUrl}">протокол HTTP</a></b> можно почитать в википедии. Обязательно это
        сделайте, если эти вещи для вас мало понятны или, что ещё хуже, вы слышите о них впервые!
    </p>

    <p>
        В ваших приложениях вы всегда будете иметь дело с HTTP запросами. Нужно понимать
        как их строить и какие данные можно положить в запрос, в зависимости от его типа.
    </p>

    <p>
        После того как запрос попал в сеть, он идёт к серверу. Сервер - это тоже программа,
        только на другой машине, которая может быть расположена в любой точке земного шара.
        Как только сервер получил запрос, он начинает его обрабатывать. Сервер получает у
        запроса всю информацию, необходимую для выборки запрошенных данных. Эта информация
        включает в себя:
    </p>

    <ul>
        <li>
            <p>
                <b>URL</b> - он же путь к запрашиваемому ресурсу. По нему сервер
                понимает, какой его метод обработки запроса должен быть вызван.
            </p>
        </li>
        <li>
            <p>
                <b>Заголовки</b> - строки в HTTP-сообщении, содержащие разделённую двоеточием
                пару параметр-значение. Например <code>X-AuthToken: vuaw672387heHh33298Sei92372wi0rsdg836194</code> - заголовок,
                передающий в запросе токен текущего залогиненного пользователя, он
                же - токен сессии. Заголовки не видны в адресной строке - они не присутствуют в URL.
            </p>
        </li>
        <li>
            <p>
                <b>Параметры запроса</b> - пары вида <code>ключ=значение</code>, которые могут быть добавлены в URL после
                знака <code>?</code>. Если параметров больше одного, они разделяются между собой символом <code>&</code>.
                Например:

                <ce:code-example-1 title="URL" />

                Здесь представлены четыре параметра: номер порции данных <code>page</code>, размер порции
                данных <code>pageSize</code>, значения фильтра: <code>onlyMe</code> и <code>startDate</code>. Параметры
                чаще передаются в запросе типа <b>GET</b>.
            </p>
        </li>
        <ul>
            <li>
                <p>
                    <b>Тело запроса.</b> Если вы передаёте в запросе данные формы, то параметры
                    запроса не подходят. Дело в том, что адресная строка может быть ограничена
                    по длине некоторыми браузерами, а также сервером. Форма может быть очень
                    большого размера. В этом случае следует использовать запрос типа <b>POST</b>
                    или <b>PUT</b>, передавая в теле данные формы. Получив запрос и определив его
                    тип, сервер понимает, что нужно извлечь данные из тела запроса. Сделав
                    это - сервер как правило сохраняет их базу данных. Запрос типа <b>POST</b>
                    используется, когда мы создаём какой-либо объект в <b>БД</b>, а <b>PUT</b> - когда
                    обновляем его.
                </p>
            </li>
        </ul>
    </ul>

    <c:url var="restUrl" value="https://ru.wikipedia.org/wiki/REST"/>
    <c:url var="restStyleUrl" value="https://restfulapi.net/resource-naming/"/>

    <p>
        Хорошей практикой является построение сервера по <b><a href="${restUrl}">архитектуре REST</a></b>. О правилах
        наименования ресурсов, а также использовании подходящих типов запросов вам расскажет
        <b><a href="${restStyleUrl}">эта замечательная статья</a></b>. Не поленитесь и изучите её полностью. В ней описаны
        лучшие практики, которых следует придерживаться при построении качественных приложений.
    </p>

    <p>
        Как только сервер узнал из запроса всё, что необходимо, он начинает связываться
        с базой данных. Если запрос был к примеру <b>GET</b> (получить какие-либо данные), сервер
        достанет из БД необходимые данные, возможно отфильтрует их, а затем отправит клиенту
        в своём ответе. Если же запрос был типа <b>POST</b> (создать что-то), сервер попытается
        сохранить данные в БД и, если все прошло удачно, пошлёт клиенту ответ с информацией
        об успехе. В противном случае пошлёт клиенту ответ с информацией об ошибке.
    </p>

    <ad:ad-content-banner-1/>

    <p>
        Стоит упомянуть тот факт, что послав последовательно <b>N</b> запросов, нет гарантии, что
        ответы придут в таком же порядке. Дело в том, что сервер на обработку этих запросов
        может тратить разное количество времени. Допустим вы послали запросы под номером <b>1</b> и <b>2</b>.
        Сначала сервер получает запрос <b>1</b> и начинает обрабатывать его. Затем он получает запрос
        <b>2</b> и тоже начинает обрабатывать. Но запрос <b>1</b> обрабатывается в <b>10</b> раз дольше, например
        из-за частого обращения в БД или слишком сложного запроса. В такой ситуации запрос <b>2</b>
        обработается быстрее и сервер тут же пошлёт клиенту ответ. Затем сервер обработает
        запрос <b>1</b> и снова пошлёт ответ. В итоге клиент сначала получит ответ <b>2</b>, а потом <b>1</b>, что
        не соответствует порядку отправленных запросов.
    </p>

    <p>
        Мы же в своём приложении должны считать, что ответы сервера всегда приходят в
        случайном порядке и проектировать свой код согласно этому предположению. Такой
        подход убережёт от странных, а порой и тяжело обнаруживаемых ошибок.
    </p>

    <c:url var="httpMDNUrl" value="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview"/>

    <p>
        Довольно подробно о клиент-серверном взаимодействии написано
        в <b><a href="${httpMDNUrl}">документации MDN</a></b>.
    </p>

    <a name="architecture"></a>
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.7.3 Архитектура</h2>
    <br/>

    <c:url var="springUrl" value="https://spring.io/"/>

    <p>
        Прежде чем приступать к написанию кода взаимодействия с сервером, необходимо
        спроектировать хорошую архитектуру. Может быть кто-то из вас знаком или слышал
        о таком популярном Java-фреймворке как <b><a href="${springUrl}">Spring</a></b>. Мы используем некоторые его
        термины и архитектурные решения.
    </p>

    <p>
        Для начала нам нужно спроектировать классы для взаимодействия с сервером. Настоящего
        сервера у нас нет, поэтому также нужна его симуляция. У нас уже
        есть компонент <code>&lt;Appointments&gt;</code>, который использует фиктивные данные
        напрямую из <code>MockData.js</code>. В таком решении есть масса недостатков: отсутствует
        пагинация, серверная сортировка и лоудер загрузки. По сути мы захардкодили
        данные. Но нам нужно, чтобы компонент <code>&lt;Appointments&gt;</code> вызывал какой-то API и
        получал данные асинхронно. Во время загрузки данных можно показывать лоудер,
        а сами данные можно подгружать порциями определённого размера.
    </p>

    <p>
        Исходя из вышеперечисленных требований, давайте создадим соответствующую архитектуру классов,
        способных решать поставленные задачи:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/mock-server-architecture.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <c:url var="drawIoUrl" value="https://www.draw.io/"/>

    <p>
        На этом рисунке представлена диаграмма классов. Я создал её с помощью <b><a href="${drawIoUrl}">этого популярного
        онлайн-инструмента</a></b>. Давайте подробно проанализируем все её элементы:
    </p>

    <ul>
        <li>
            <p>
                <b>Appointments</b> - это наш уже существующий компонент, который
                нуждается в API для асинхронной загрузки данных.
            </p>
        </li>
        <li>
            <p>
                Уровень сервисов - все классы-сервисы приложения, унаследованные от класса
                <b>BaseService</b>. Они предоставляют API для асинхронной загрузки данных и будут
                расположены в папке <code>/services</code> приложения.
            </p>
            <ul>
                <li>
                    <p>
                        <b>BaseService</b> - базовый абстрактный класс для всех сервисов. Он инкапсулирует какую-либо
                        библиотеку для выполнения HTTP запросов (например <b>jquery</b> или <b>superagent</b>) и вызывает её
                        в своём методе <code>request(params)</code>. Этот метод возвращает объект класса <code>Promise</code> и принимает
                        параметры запроса в объекте <code>opts</code>.
                    </p>
                </li>
                <li>
                    <p>
                        <b>AppointmentService</b> - класс-наследник <code>BaseService</code>. Он предлагает API для асинхронной
                        загрузки данных. В нашем случае API представлен методом <code>find(params)</code>. Этот метод
                        вызывает унаследованный метод <code>request(params)</code> своего предка и принимает параметры
                        поиска приёмов: размер и номер порции данных, параметры фильтрации.
                    </p>
                </li>
            </ul>
        </li>
        <li>
            <p>
                <b>MockServer</b> - фиктивный сервер обрабатывающий запросы и возвращающий фиктивные данные с
                установленной задержкой, симулирующей время ожидания ответа настоящего сервера.
            </p>
            <ul>
                <li>
                    <p>
                        <b>MockServer</b> - класс фиктивного сервера, который выполняет маршрутизацию запроса на
                        соответствующий контроллер. Он предоставляет публичный метод <code>service()</code> для
                        обслуживания запроса.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Уровень контроллеров</b> - все классы-контроллеры фиктивного сервера приложения,
                        унаследованные от класса <code>Controller</code>. Контроллеры предоставляют API для своей
                        маршрутизации и получения списка своих обработчиков запроса вместе с
                        соответствующими путями.
                    </p>
                    <ul>
                        <li>
                            <p>
                                <b>Controller</b> - базовый абстрактный класс обработчика запросов. Название
                                позаимствовано с фреймворка Spring MVC. Он предоставляет самый важный публичный
                                метод <code>handle()</code>, который выполняет обработку запроса. Все потомки этого класса
                                должны переопределять метод <code>getHandlers()</code>, который возвращает список элементов
                                вида: <code>{ path: ‘/appointments’, handler: (vars, params) => {} }</code>,
                                где <code>path</code> - это определённый путь, а <code>handler</code> - соответствующий
                                обработчик. Метод <code>handle()</code> вызывает метод <code>getHandlers()</code> и
                                определяет какой обработчик вызвать, в соответствии с текущим
                                путём. Метод API <code>getPath()</code> используется классом <code>MockServer</code> для маршрутизации
                                запроса на соответствующий контроллер.
                            </p>
                        </li>
                        <li>
                            <p>
                                <b>AppointmentController</b> - конкретный контроллер, расширяющий класс <code>Controller</code>. Он обрабатывает
                                все запросы, связанные с приёмами: список, детали, количество, удаление, обновление, сохранение и пр.
                            </p>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <p>
                <b>Real Server</b> - некий реальный сервер, возвращающий настоящие данные. У нас его нет,
                поэтому мы создадим фиктивный, симулирующий задержку обработки запроса и
                возвращающий фиктивные данные.
            </p>
        </li>
    </ul>

    <c:url var="spring1Url" value="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-first-example"/>
    <c:url var="springMvcUrl" value="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller"/>

    <p>
        Как я уже упоминал, архитектурные решения, в частности уровень сервисов и уровень контроллеров
        взяты из фреймворков Spring<b><a href="${spring1Url}"></a></b> и Spring MVC<b><a href="${springMvcUrl}"></a></b>.
    </p>

    <c:url var="umlUrl" value="https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0_%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8"/>

    <p>
        Для полного понимания специфики работы наших классов, можно построить
        <b><a href="${umlUrl}">диаграмму последовательности</a></b>,
        на которой сперва будет отражено взаимодействие с реальным сервером:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/action-diagram_real-server.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        Как показывает диаграмма, сначала компонент <code>Appointments</code> вызывает метод <code>find()</code>
        API класса <code>AppointmentService</code>. Последний сразу возвращает объект типа <code>Promise</code> и
        выполняет HTTP запрос на сервер, используя метод унаследованный метод <code>request(params)</code>.
        Как только сервер получает запрос в момент времени <b>A</b>, он начинает обработку запроса
        до момента времени <b>B</b> и возвращает ответ. Как только ответ приходит на клиент,
        компонент <code>Appointments</code> получает его в методе <code>then()</code> в виде объекта <code>response</code>.
    </p>

    <p>
        Только что было описано взаимодействие с реальным сервером. Теперь нужно модифицировать
        диаграмму для работы с фиктивным сервером:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/action-diagram_mock-server.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        Здесь, с того момента, как класс <code>AppointmentService</code> вызывает метод
        <code>request(params)</code> реального HTTP запроса не происходит. Вместо этого мы
        вызываем метод <code>service(request)</code> класса, <code>MockServer</code>. Этот метод сначала
        выполняет маршрутизацию запроса на контроллер <code>AppointmentController</code>,
        а затем вызывает его метод <code>handle(request)</code>. Далее в методе <code>handle(request)</code>
        класс <code>AppointmentController</code> находит и вызывает свой обработчик, полностью
        соответствующий пути запроса. Найденный обработчик в свою очередь вызывает
        метод <code>getAppointments()</code> фиктивной базы данных <code>MockData</code>.
    </p>

    <ad:ad-content-banner-2/>

    <p>
        После того как метод <code>getAppointments()</code> возвращает данные обработчику,
        последний возвращает их методу <code>handle(request)</code> класса <code>AppointmentController</code>,
        а тот в свою очередь возвращает их методу <code>service(request)</code> класса <code>MockServer</code>.
        Здесь стоит остановиться. Дело в том, что данные до этого момента были получены
        почти мгновенно. А как нам уже известно, настоящему серверу нужно определённое
        время, чтобы обработать запрос. Нам нужно симулировать это время в фиктивном
        сервере <code>MockServer</code>. Для этого будем использовать всем известную
        конструкцию: <code>setTimeout(() => { //отправить ответ }, RESPONSE_DELAY)</code>.
        Мы установим определённую задержку <code>RESPONSE_DELAY</code> и по истечении этого
        времени вернём ответ классу <code>AppointmentService</code>.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>5.7.4 Реализация</h2>
    <br/>

    <p>
        Мы построили архитектуру асинхронной загрузки данных. Теперь самое время
        приступить к реализации всех её элементов. Для лучшего понимания будем двигаться “с конца”,
        то есть начнём с файла <code>MockData.js</code>, а закончим модификацией компонента <code>&lt;Appointments&gt;</code>.
        Что ж, давайте приступим!
    </p>

    <br/>
    <h3>5.7.4.1 Фиктивный бэкэнд</h3>
    <br/>

    <p>
        Давайте модифицируем файл <code>MockData.js</code> в соответствии с нашей новой архитектурой.
        На диаграмме последовательности вы могли заметить метод <code>getAppointments()</code>.
        Этот метод мы будем использовать вместо переменной appointments, переместив в
        него код фильтрации данных из компонента <code>&lt;Appointments&gt;</code>:
    </p>

    <ce:code-example-2/>

    <p>
        Тем самым мы <b>переместили логику</b> фильтрации данных <b>с клиента на сервер!</b>
    </p>

    <app:alert title="Совет!" type="success">
        По возможности лучше перемещать любую логику работы с данными на сервер, а клиент
        делать максимально простым. Это напрямую связано с ресурсами: сервер, как правило,
        обладает гораздо большими ресурсами, чем клиент: жесткий диск, процессор,
        оперативная память - среднестатистическая машина пользователя обычно
        слабее (часто гораздо слабее) серверной.
    </app:alert>

    <p>
        Сделав клиент простым, он будет работать очень быстро, доставляя пользователю
        удовольствие от работы с приложением. Фильтрацию, сортировку и пагинацию, за редким
        исключением, следует выполнять именно на сервере. Если вы видите, что реализованная
        вами логика работает не так быстро, как хотелось бы, самое время рассмотреть возможность
        её переноса на сервер, это может оказаться настоящим спасением.
    </p>

    <p>
        <b>В идеале, клиент должен получить данные с сервера и сразу показать их.</b> Конечно,
        нередки ситуации, где нужно что-то посчитать или немного преобразовать исходные данные.
        Главное здесь следить за тем, чтобы эти преобразования не давали просадки в производительности.
        Если это происходит, то преобразования следует выполнить на сервере или придумать более
        подходящий формат данных. Если ничего не помогает, возможно, ошибка кроется в архитектуре
        клиента или сервера. Тогда следует провести исследование и перепроектировать проблемные части.
    </p>

    <p>
        С фиктивными данными мы разобрались. Время перейти к уровню/слою контроллеров. Как упоминалось
        ранее, в нашем приложении контроллер - это конечная остановка обработки запроса. Но это только
        в нашем фиктивном сервере. В реальном сервере это не так. Если к примеру изучить архитектуру
        реального Java-сервера, использующего, скажем, Spring MVC, то контроллер - это только точка
        входа на сервер. В таком сервере, архитектура может выглядеть следующим образом:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/mock-server-architecture-2.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        На диаграмме представлена трёхуровневая архитектура сервера, которая включает:
        уровень контроллеров, уровень сервисов и уровень доступа к данным. Давайте рассмотрим
        основные задачи этих уровней:
    </p>

    <ul>
        <li>
            <p>
                <b>Контроллер</b> принимает HTTP запрос клиента и начинает обрабатывать его. Допустим
                запрос приходит на метод <code>find()</code>. Метод достаёт из запроса всю необходимую информацию,
                а затем вызывает одноимённый метод <code>find()</code> сервиса.
            </p>
        </li>
        <li>
            <p>
                <b>Сервисы</b> представлены соответствующим уровнем и обычно выполняют разнообразную бизнес-логику.
                Они обращаются за данными к классам уровня доступа к данным и выполняют над ними разные преобразования.
            </p>
        </li>
        <li>
            <p>
                Классы уровня доступа к данным производят запросы прямо в БД. Для этого они, как правило,
                используют какой-нибудь фреймворк, или библиотеку (для <b>Java</b> это <b>JPA</b>,
                <b>Hibernate</b>, <b>JDBC</b> и пр.)
            </p>
        </li>
    </ul>

    <p>
        Архитектура может содержать и больше уровней, например четыре или пять. Это зависит
        от предметной области. В Java серверах чаще всего используют трёх или
        четырёхуровневую архитектуру.
    </p>

    <p>
        Если вы никогда раньше не сталкивались с написанием сервера, информация выше определённо
        даст вам общее понимание принципов его проектирования и работы. Знание этого - существенный
        плюс для UI разработчика, ведь это помогает правильно распределить задачи между
        клиентом и сервером!
    </p>

    <p>
        В нашем фиктивном сервере нет необходимости в уровнях сервисов и доступа к данным.
        Какую-либо бизнес-логику мы можем написать прямо в файле <code>MockData.js</code>, а в контроллере
        лишь доставать конечные данные. Но если файл <code>MockData.js</code> становится довольно большим,
        возможно, уровень сервисов всё же следует добавить. В любом случае это не займёт много времени.
    </p>

    <p>
        Давайте создадим базовый класс-контроллер, от которого мы будем наследовать все
        остальные контроллеры:
    </p>

    <ce:code-example-3/>

    <p>
        Со всеми его методами мы уже знакомы. Методы <code>getPath()</code>
        и <code>getHandlers()</code> будут переопределены потомками. А вот
        метод <code>handle()</code> нужно реализовать именно здесь,
        затем он будет унаследован.
    </p>

    <p>
        Как было сказано ранее, метод <code>handle()</code> вызывает метод <code>getHandlers()</code> и
        определяет какой обработчик должен быть вызван в соответствии с текущим
        путём. То есть он сопоставляет все имеющиеся пути с путём, указанным в
        запросе. Для такой задачи можно использовать специальную библиотеку.
    </p>

    <c:url var="urlPatternUrl" value="https://github.com/snd/url-pattern"/>

    <p>
        Представляю вам мощный инструмент <b><a href="${urlPatternUrl}">url-pattern</a></b>. Он даёт богатый спектр
        возможностей для работы с путями: соответствие, получение переменных
        пути и параметров запроса и многое другое.
    </p>

    <p>
        Используя эту библиотеку, реализация метода <code>handle()</code> получается очень простой:
    </p>

    <p>
        В этом методе мы вызываем метод <code>getHandlers()</code>, получая список пар
        <code>{ path, handler }</code>. Далее в цикле мы идем по этому списку и находим
        соответствующий путь с помощью <code>pattern.match(url)</code>. Найдя нужный путь мы
        вызываем соответствующий обработчик <code>handler(vars, params)</code>, передавая в него
        переменные пути и параметры запроса.
    </p>

    <p>
        Базовый контроллер готов, настало время перейти к
        контроллеру <code>AppointmentController</code>:
    </p>

    <ce:code-example-5/>

    <p>
        Как уже говорилось ранее, здесь реализованы методы <code>getPath()</code> и <code>getHandlers()</code>.
        Первый возвращает корневой путь <code>/appointments</code>,  по которому будет осуществляться
        маршрутизация в классе <code>MockServer</code>. Второй возвращает список пар
        путь-обработчик: <code>{ path, handler }</code>. В качестве примера я привёл еще две
        пары с путями <code>/:appointmentId</code> и <code>/count</code>, которые позже вы можете раскомментировать
        и реализовать самостоятельно.
    </p>

    <p>
        Что ж, наш бэкэнд почти готов. Осталось реализовать самый
        главный класс: <code>MockServer</code>.
    </p>

    <ce:code-example-6/>

    <p>
        Здесь всё также предельно просто. Сначала мы импортируем все реализованные
        контроллеры и регистрируем их в переменной <code>ROUTING</code>. Далее в основном
        методе <code>service()</code> мы возвращаем промис. Внутри мы вызываем <code>setTimeout()</code> c
        задержкой <code>RESPONSE_DELAY</code> для имитации времени обработки запроса. По истечении
        заданной задержки мы в цикле проходим все ключи <code>ROUTING</code> и сверяем их с
        текущим путём с целью найти подходящий контроллер. Так мы имитируем
        серверную маршрутизацию. Как только подходящий контроллер найден,
        обрабатываем запрос и посылаем ответ <code>controller.handle(request)</code> клиенту.
    </p>

    <ad:ad-content-banner-3/>

    <p>
        В этой реализации не учтена одна вещь, фиктивный сервер должен работать
        наравне с реальным. То есть для приложения они должны быть неотличимы!
        Для этого фиктивный и реальный сервер должны возвращать ответ одного формата.
        Сейчас наш фиктивный сервер возвращает данные напрямую и это может вызвать
        несовместимость. Для решения этой задачи нам необходимо реализовать
        имитацию ответа сервера.
    </p>

    <p>
        Давайте модифицируем класс <code>MockServer</code>, добавив в него два новых метода
        <code>getSuccessResponse()</code> и <code>getFailureResponse()</code> имитирующих ответ сервера в
        случаях успеха или ошибки:
    </p>

    <ce:code-example-7/>

    <p>
        Приведенная структура ответа сервера не обязана быть точь в точь такой.
        Хотя представленная довольно хороша, и я постоянно использую её в своих
        проектах с определёнными модификациями. Стоит также помнить, что <b>такую же
        реализацию ответа должен возвращать и реальный сервер</b>, чтобы избежать
        проблем с совместимостью.
    </p>

    <p>
        Метод <code>getSuccessResponse()</code> по итогу возвращает объект-ответ:
    </p>

    <p>
        Метод <code>getFailureResponse()</code> в свою очередь возвращает объект-ответ:
    </p>

    <ce:code-example-8/>

    <p>
        На этом реализация фиктивного сервера подошла к концу. Он может
        принимать, маршрутизировать, и обрабатывать запрос, после чего посылать
        ответ клиенту спустя установленное время задержки. Что ж, настало время
        написать код, который будет посылать запрос нашему серверу и принимать
        от него ответ. Этим занимаются сервисы.
    </p>

    <br/>
    <h3>5.7.4.2 Уровень сервисов</h3>
    <br/>

    <p>
        Вспомним нашу диаграмму классов из раздела <b><a href="#architecture">Архитектура</a></b>:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/mock-server-architecture.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        На ней видно, что слой сервисов взаимодействует с реальным сервером по
        протоколу HTTP или вызывая метод <code>service()</code> фиктивного. Результат для двух
        случаев должен быть одинаков. То есть у вас должна быть возможность переключаться
        между серверами в любой момент времени. Например вы узнали, что метод API для списка
        клиентов на реальном сервере готов. Тогда вы можете переключить приложение на
        реальные данные именно для этого метода. Нам необходимы классы для гибкого
        взаимодействия с серверами. Именно этим и будут заниматься наши сервисы.
    </p>

    <p>
        Как это уже было с контроллерами, начнём с базового класса. Он имеет один
        публичный метод <code>request()</code>, с помощью которого и осуществляется запрос на сервер.
        Мы начнём с самой простой реализации, а затем будем расширять её, приводя в
        соответствие с нашими требованиями.
    </p>

    <p>
        Итак, самая простая реализация базового сервиса будет иметь следующий вид:
    </p>

    <ce:code-example-9/>

    <p>
        Как видно, код предельно простой. Мы просто обращаемся к нашему фиктивному
        сервер с помощью метода <code>service()</code>. Метод <code>request()</code>
        возвращает <code>Promise</code> коду, который его вызывает.
    </p>

    <p>
        Здесь нет возможности переключиться на реальный сервер, а это жизненно необходимо,
        так как приложение, работающее только с фиктивными данными никому не нужно. Чтобы
        добавить такую возможность, следует начать с модификации файла конфигурации
        приложения <code>config.js</code>. В нём будет флаг переключения и URL удалённого сервера:
    </p>

    <ce:code-example-10/>

    <p>
        Отлично! Флаг и адрес удалённого сервера мы будем считывать в классе <code>BaseService</code>.
        Далее в зависимости от значения флага, будем обращаться к фиктивному или реальному серверу:
    </p>

    <ce:code-example-11/>

    <p>
        Итак, переключение готово. Но что если мы хотим, чтобы одна часть методов работала
        с реальными данными, а другая с фиктивными? Ведь такая ситуация будет постоянно, пока
        ведется разработка сервера. Давайте немного модифицируем наш код, добавив такую возможность:
    </p>

    <ce:code-example-12/>

    <p>
        Все пути приложения будем помещать в переменную <code>notImplementedTemplates</code>.
        Если какие-то из них уже готовы на сервере, их можно закомментировать, как
        это сделано для примера с <code>'/clients'</code>. Флаг <code>isNotImplemented</code> показывает,
        реализован ли на реальном сервере путь текущего запроса. Условие
        позволяет <code>!remote.isEnabled || isNotImplemented</code> вызывать фиктивный
        сервер, даже если активирован режим работы с реальным сервером, в
        случае если запрашиваемый путь не реализован.
    </p>

    <c:url var="superagentGitUrl" value="https://github.com/visionmedia/superagent"/>
    <c:url var="superagentUrl" value="http://visionmedia.github.io/superagent/"/>

    <ad:ad-content-banner-4/>

    <p>
        Сейчас у нас есть полноценная возможность переключения между серверами вплоть
        до отдельного метода. Это конечно замечательно, но мы до сих пор не можем
        обращаться к реальному серверу. Зато у меня есть отличный повод познакомить
        вас с прекрасной библиотекой <b><a href="${superagentGitUrl}">superagent</a></b>.
        <b><a href="${superagentUrl}">Здесь представлена</a></b> её полная документация.
    </p>

    <p>
        Эта мощная библиотека покрывает практически все случаи взаимодействия с
        сервером через AJAX. Вы можете делать запросы любых типов (GET, PUT и пр.),
        а также посылать и принимать файлы! Помимо прочего библиотека предоставляет
        простой и удобный интерфейс, а также проста в изучении.
    </p>

    <p>
        Что ж, библиотека у нас есть (не забудьте ее подключить). Всё, что
        осталось - это определить, какие типы запросов наш базовый сервис
        будет посылать. Вообще для CRUD операций нужны лишь следующие
        типы: GET - получение данных, POST - создание нового объекта
        на сервере, PUT - модификация объекта на сервере и DELETE -
        удаление объекта на сервере. Основываясь на этом, финальная
        версия базового сервиса будет выглядеть так:
    </p>

    <ce:code-example-12/>

    <p>
        Итак, давайте по-порядку. В самом верхнем блоке <code>else</code> метода <code>request()</code>
        появился код, который в зависимости от типа запроса по-разному конфигурирует
        библиотеку <code>superagent</code>, а точнее её инструмент построения запроса <code>request</code>:
    </p>

    <ul>
        <li>
            <p>
                Блок с условием <code>method === 'GET'</code> инициализирует запрос, устанавливая
                целевой URL, время ожидания запроса <code>config.responseTimeout</code>, заголовки
                (c помощью <code>rq.set()</code>)  и параметры (с помощью <code>rq.query()</code>). Затем он
                посылает этот запрос на сервер, вызывая <code>.then()</code>.
            </p>
        </li>
        <li>
            <p>
                Блок с условием <code>method === 'POST' || method === 'PUT'</code>  инициализирует запрос,
                сперва устанавливая метод, целевой URL, тип кодирования данных и время ожидания запроса.
                Дальнейшая инициализация будет отличаться для разных типов типов кодирования данных
                формы <code>type</code>. Если тип равен <code>'multipart/form-data'</code>, тело запроса может содержать
                как файлы, так и строковые значения. Для файлов мы используем метод <code>rq.attach()</code>,
                а для обычных значений <code>rq.field()</code>, предварительно преобразовав в строки объекты.
                В всех остальных случаях используем просто <code>rq.send()</code>.
            </p>
        </li>
        <li>
            <p>
                Блок с условием <code>method === 'DELETE'</code>  инициализирует запрос, устанавливая то
                же что и GET, только без параметров и заголовков. Хотя при желании
                последние можно добавить.
            </p>
        </li>
    </ul>

    <p>
        Представленная реализация, учитывающая типовые запросы, покрывает почти все
        стандартные потребности приложения. Если у вас есть какие-то специфические
        ситуации, код можно легко модифицировать.
    </p>

    <p>
        Также я убрал добавление заголовков со всех типов запросов, кроме GET.
        Я сделал это умышленно, так как в нашем приложении мы не отправляем никаких
        заголовков. В реальных же приложениях, заголовки, как правило, должны
        передаваться для всех типов запросов. Типичные примеры: токен аутентификации
        текущего пользователя, версия фронтэнда, требуемая версия бэкэнда и пр. Если
        такая необходимость существует, можно просто скопировать код добавления
        заголовков из GET в остальные типы запросов, или вынести его в общую для
        всех типов инициализацию запроса.
    </p>

    <p>
        Двигаемся дальше. Как вы могли заметить, я добавил два
        обработчика: <code>onSuccess()</code> и <code>onFailure()</code>. Они важны, так как
        срабатывают сразу после того, как пришёл ответ от сервера.
    </p>

    <p>
        Метод <code>onSuccess()</code> срабатывает в том случае, если сервер успешно обработал
        запрос. В начале этого метода стоит блок <code>try/catch</code>, где происходит парсинг
        строки ответа, пришедшей с сервера.
    </p>

    <app:alert title="Внимание!" type="warning">
        Напомню, что для нашего приложения сервер должен возвращать строку <code>json</code>,
        имеющей структуру, совпадающую со структурой объектов, которые возвращают
        методы <code>getSuccessResponse()</code> и <code>getFailureResponse()</code>. Для вашего же приложения
        строка запроса может быть какой-угодно - вы определяете это сами. Я лишь дал
        один удобный вариант структуры ответа сервера из множества возможных.
    </app:alert>

    <c:url var="responsePropertiesUrl" value="http://visionmedia.github.io/superagent/#response-properties"/>

    <p>
        Дело в том, что наша библиотека <b>superagent</b> при получении ответа создаёт
        объект класса <code>Response</code>. Этот JS-объект является удобным представлением
        ответа сервера и предлагает разные <b><a href="${responsePropertiesUrl}">полезные свойства для чтения</a></b>. Сейчас
        больше всего нас интересуют свойства <code>body</code> и <code>text</code>. Выдержка из документации:
    </p>

    <p>
        <b>Response text</b>
    </p>

    <p style="font-size: 12px">
        The <code>res.text</code> property contains the unparsed response body string. This property is
        always present for the client API, and only when the mime type matches "text/*", "*/json",
        or "x-www-form-urlencoded" by default for node. The reasoning is to conserve memory, as
        buffering text of large bodies such as multipart files or images is extremely inefficient.
        To force buffering see the "Buffering responses" section.
    </p>

    <p>
        <b>Response body</b>
    </p>

    <p style="font-size: 12px">
        Much like SuperAgent can auto-serialize request data, it can also automatically parse it.
        When a parser is defined for the Content-Type, it is parsed, which by default includes
        "application/json" and "application/x-www-form-urlencoded". The parsed object is then
        available via <code>res.body</code>.
    </p>

    <p>
        В свойстве text хранится, переданная с сервера строка ответа. В нашем приложении это
        будет строка JSON. Именно её и парсит наш блок <code>try/catch</code>.
    </p>

    <p>
        Однако парсить может и сама библиотека. На текущий момент поддерживаются
        следующие типы <code>response-body</code> для парсинга:
    </p>

    <ul>
        <li>
            <p>
                application/x-www-form-urlencoded
            </p>
        </li>
        <li>
            <p>
                application/json
            </p>
        </li>
        <li>
            <p>
                multipart/form-data
            </p>
        </li>
    </ul>

    <p>
        Результат парсинга и будет помещён в свойство <code>body</code>. Вы даже можете
        задать свой собственный парсер строки ответа сервера.
    </p>

    <p>
        C учётом вышесказанного, метод <code>onSuccess()</code> может выглядеть вот так:
    </p>

    <p>Нет никакой разницы, какой из этих способов использовать.</p>

    <app:alert title="Внимание!" type="warning">
        Важно отметить, что текущие реализации <code>onSuccess</code> и <code>onError</code> справедливы только
        для библиотеки <b>superagent</b>. Если использовать, например, <b>JQuery</b>, то код методов
        нужно изменить, так как <b>JQuery</b> не создаёт объект класса <code>Response</code>.
    </app:alert>

    <p>
        За блоком <code>try/catch</code> идет условие:
    </p>

    <ce:code-example-15/>

    <p>
        Оно стоит не просто так. Дело в том, что если сервер обработал запрос, то не факт что пришли
        именно те данные, которые ожидались. Сервер мог обработать запрос без сбоев, но ошибка
        могла возникнуть где-то в бизнес-логике.
    </p>

    <p>
        Например, вы хотели получить список клиентов для другого пользователя,
        но у вас недостаточно прав. Сервер может обработать запрос без сбоев, но
        вернёт вам ответ с ошибкой и кодом отличным от <code>200</code>. Тогда на клиенте может
        сработать <code>onSuccess</code>, а не <code>onError</code> - это зависит только от реализации сервера!
        То есть мы заранее можем не знать, что сработает <code>onSuccess</code> или <code>onError</code>.
    </p>

    <p>
        Конечно, теоретически можно реализовать сервер таким образом, что на любую
        серверную ошибку будет всегда срабатывать <code>onError</code>, однако это не всегда возможно
        на практике. Например разработка UI может вестись для уже готового сервера, а
        изменять его может быть нецелесообразно: дорого, риски регрессии и пр.
    </p>

    <p>
        Именно поэтому в методе <code>onSuccess</code> стоит условие:
    </p>

    <ce:code-example-15/>

    <p>
        Оно отсеивает лишь успешно выполненный запрос с ожидаемыми данными.
        Если этот так, мы возвращаем лишь необходимые данные <code>body</code>, обрезая все лишние.
        Если же код ответа сервера не проходит условие, мы сами генерируем ошибку
        собственного типа <code>ServerError</code>, помещая туда всю информацию о возникшей проблеме.
    </p>

    <p>
        Далее идет обработчик <code>onFailure()</code>. Он обрабатывает сбои сервера. Это значит,
        что сервер мог "свалиться" во время обработки запроса. То есть могло возникнуть
        исключение, типа <code>NullPointerException</code> - ошибка нулевого указателя, или деление
        на ноль. Так же могло пропасть соединение с сервером или превышено время ожидания
        ответа - то есть ответ так и не пришёл! Во всех этих ситуациях сработает <code>onFailure()</code>,
        в котором мы генерируем свою ошибку типа <code>ServerError</code> (или другого типа), передав
        в неё всю необходимую информацию.
    </p>

    <p>
        Созданные мной классы ошибок имеют следующий вид:
    </p>

    <br/>

    <p class="text-center" style="overflow-x: auto">
        <img src="<c:url value="/resources/imges/training-project/error-classes.png"/>" class="text-center">
    </p>

    <br/>
    <br/>

    <p>
        Их код:
    </p>

    <ce:code-example-16/>

    <p>Я поместил их в папку <code>/lib/errors/</code>.</p>

    <p>
        Код code - это кастомный читабельный строковый код ошибки, приходящий с сервера,
        имеющий вид <code>'session.timeout'</code>, <code>'invalid.token'</code>, <code>'incorrect.user.email'</code> и пр. Он может
        понадобиться для того, чтобы отлавливать  в приложении определенные ошибки, сверять
        их по этому коду и далее делать какие-либо специфические действия, например:
    </p>

    <ce:code-example-17/>

    <p>
        Это очень удобно, так как способствует лучшему пониманию кода. Читабельные
        строки гораздо понятнее цифр. Эти строковые коды должны быть реализованы на
        сервере, то есть бэкэнд разработчики должны вставлять его в ошибку, чтобы
        вы могли правильно его обрабатывать.
    </p>

    <p>
        Поле <code>message</code> - это сам текст ошибки, например <code>'Your session has been expired'</code>.
        Поле <code>status</code> представляет целочисленный статус, например <code>500</code>, <code>501</code> и т.д.
    </p>

    <p>
        Данные классы ошибок необязательны, но они существенно помогают унифицировать
        работу с серверными ошибками в приложении. Обработчики <code>onSuccess</code> и <code>onFailure</code>
        являются своего рода адаптерами. Они преобразуют ответ сервера в форму,
        понятную приложению.
    </p>

    <p>
        Что ж, с базовым сервисом мы закончили. Осталось создать
        сервис-наследник <code>AppointmentService</code>:
    </p>

    <ce:code-example-18/>

    <p>
        Как видно из кода, этот сервис в своих методах просто вызывает метод <code>request()</code>
        своего предка, передавая все необходимые параметры. Каждый метод возвращает промис
        коду-потребителю. На текущий момент у нас есть лишь один метод <code>find ({ filter })</code>,
        который принимает фильтр в качестве параметра и запрашивает список приёмов. Для
        примера я добавил еще два закомментированных метода: <code>findById(appointmentId)</code> и <code>count()</code>.
        Первый находит информацию о приёме по идентификатору, а второй возвращает общее
        количество всех приёмов для данного пользователя.
    </p>

    <ad:ad-content-banner-5/>

    <p>
        На этом всё! Слой сервисов готов. Осталось последнее: модифицировать
        компонент <code>&lt;Appontments&gt;</code>, добавив в него возможность использования нашего сервиса.
    </p>

    <br/>
    <h3>5.7.4.3 Модификация списка приёмов</h3>
    <br/>

    <p>
        Нам остался последний шаг. Необходимо модифицировать список приёмов, и
        самое главное, что нужно сделать - вызвать сервис <code>AppointmentService</code> в
        компоненте <code>&lt;Appontments&gt;</code>. Как мы установили ранее, загрузка данных будет
        происходить некоторый промежуток времени. В течение этого промежутка
        пользователю следует показывать процесс загрузки (например гифку),
        чтобы он видел что происходит какое-то действие. Учитывая всё вышесказанное,
        итоговая версия кода будет следующей:
    </p>

    <ce:code-example-19/>

    <p>
        Код изменился незначительно. Добавился метод <code>load()</code>, который вызывает метод
        <code>find()</code> сервиса, а также устанавливает флаг <code>isLoading</code>, сигнализирующий о том,
        происходит загрузка или нет. Используя этот флаг в методе <code>render()</code>, пользователю
        будет показан компонент <code>&lt;Loader &gt;</code>, в случае если загрузка осуществляется,
        или компонент <code>&lt;Table &gt;</code>, если таковой не происходит.
    </p>

    <p>Вот и всё! Наш код, использующий асинхронную загрузку данных, полностью готов:</p>

    <br/>

    <iframe
            height="400px"
            width="100%"
            src="https://repl.it/@stsiushkevich/custom-app-v-3-7?lite=true"
            scrolling="no"
            frameborder="no"
            allowtransparency="true"
            allowfullscreen="true"
            sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>

    <br/>
    <br/>

    <p>
        Следующим и финальным нашим шагом станет добавление состояния приложения.
        О том, что это такое и зачем это нужно, вам подробно расскажет следующий раздел.
    </p>
</lt:layout>

<c:url var="prevPageUrl" value="/training-project/routing"/>
<c:url var="nextPageUrl" value="/training-project/app-state"/>

<app:page-navigate
        prevPageUrl="${prevPageUrl}"
        pageStartAncor="pageStart"
        nextPageUrl="${nextPageUrl}"
/>